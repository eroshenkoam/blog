# А ты знаешь на сколько стабильны твои тесты?

Вопрос стабильности тестов становится более актуальным с ростом их количества. 
Пока у вас 10 тестов или 100 - найти сломанные тесты не составляет труда. 
Другое дело, когда их количество переваливает за 2000 :)

Сегодня я расскажу как обнаружить все подозрительные тесты за 3 минуты при наличии Allure отчета. Поехали. 

## Проблема

Есть проект с 1000+ тестов. Тесты постоянно запускаются. 
Как найти тесты с максимальным количеством падений (минимальный success rate)?

## Идея

Если открыть вкладку History для конкретного теста в Allure отчете, то вы увидите следующую информацию: 
* коэффициент стабильности за последние 20 запусков
* пять последних запуск теста 

Собственно, этот коэффициент нам и интересен, на кликать по каждому тесту при условии что их 1000+ кажется нелепым занятием.
Можно это автоматизировать! :)

## Решение

Если заглянуть внутрь директории с Alure отчетом, то мы увидим следующуу структуру: 
```
- apps.js
+ data 
+ export
...
```

Для нас представляет интерес директория `data`, а точнее ее содержимое `data/test-cases/*`. 
В этой директории находится информация о всех результатах тестов, которая отображается в отчете. 
Соответственно, в каждом таком файле находится информация о последних запусках тестов и коэффициент стабильности. 
Нам бы эти файлы как-нибдуь "покверить" и получить результат. 

Первой идеей было все закинуть в монгу и кверить там :) Но для этого нужно поднять эту самую монгу. 
Есть более элегантное решение, библиотека jq - https://stedolan.github.io/jq. 
Эта библиотека создана для аналази json файликов и и имеет довольно много крутых фичей. 

Для того, чтобы воспользоваться этой библиотекой нужно минимальное знание консоли, но оно того стоит.
Сначала подготовка: 
1. Устанавливаем библиотеку
2. Заходим в диреткорию с результатами тестов - `cd allure-report/data/test-cases`
3. Все следующие примеры выполняются в директории указанной выше.

### Список всех тестов в репорте

Давайте откроем любой файлик json и посмотрим его содержимое: 
```
{
  "uid" : "2622770e9fd47ddd",
  "name" : "Создание заявки на на платеж",
  "fullName" : "ru.autotests.PaymentTest.transferTest",
  "status" : "failed",
  "extra": { 
    "history": {
      "statistic": {
        "failed" : 12,
        "broken" : 0,
        "skipped" : 1,
        "passed" : 0,
        "unknown" : 0,
        "total" : 13
      }
    }
  }
  ...
}
```
На самом деле там гораздо больше информации, но нам хватит и этой. 

### Список всех тестов
Итак, давайте выведем список всех тестов, которые были запущены. 
Для этого выполняем команду `cat *.json | jq -s ".[] | .fullName"`. 
Давайте разберем подробно что произошло: 
* `cat *.json` - печатаем содержимое всех результатов в формате json 
* `<1> | <2> ` - передаем результат команды 1 в команду 2
* `jq -s "..."` - парсим результаты с помощью утилиты jq: 
  * .[] - складываем все результаты в массив
  * .fullName - для каждого результата извлекаем поле fullName

Таким образом мы распечаем список всех fullName для запущенных тестов. 

### Список всех тестов и количество их запусков

`cat *.json | jq -s ".[] | {test: .fullName, launches: .extra.history.statistic.total}"`
Тут появляется операция вида {...}. Что же она значит?
Это операция позволяет сконструировать новый json объект на базе старых данных. 
Получивший результат будет выглядеть следующим образом: 
```
{
  "test": "ru.package.Class.method",
  "launches": 13
}
{
  "test": "ru.package.Class2.method2",
  "launches": 12
}
```
Т.е выконвертируете список json файлов в один json, но этот json не валидный. 
Чтобы сделать его валидным нужно добавить скобки над всем выражением:
`cat *.json | jq -s "[.[] | {test: .fullName, launches: .extra.history.statistic.total}]"`
Результат:
```
[
  {
    "test": "ru.package.Class.method",
    "launches": 13
  },
  {
    "test": "ru.package.Class2.method2",
    "launches": 12 
  }
]  
```
Теперь у нас есть полноценная коллекция результатов и количество их запусков. 

### Вычисляем коэффициент стабильности

Делим количество успешных запусков на обзее количество и умножаем на 100. Все довольно просто. 
Вся эта ифнформация у нас есть в exta.history.statistic, нужно только составить запрос. 
У меня этот запрос получился таким: 
```
cat *.json | jq -s "[.[] | { test: .fullName, rate: (.extra.history.statistic.passed / .extra.history.statistic.total * 100) }]
```
Результат выполнения меня опечалил: 
```
jq: error (at <stdin>:2310561): null (null) and null (null) cannot be divided
```
Это происходит потому что в конкретном запуске есть тесты, у которых нет истории, по-этому нет блока extra.history. 
Давыайте добавим фильтрацию по этому признаку: `select(.extra.history.statistic != null)`. 
Результирующий запрос стал выглядеть следующим образом:   
```
cat *.json | jq -s "[.[] | select(.extra.history.statistic != null) | { test: .fullName, rate: (.extra.history.statistic.passed / .extra.history.statistic.total * 100) }]
```
Результатом его выполнения будет: 
```
[
  {
    "test": "ru.package.Class.method",
    "rate": 0
  },
  {
    "test": "ru.package.Class2.method2",
    "rate": 83.33333333333334 
  }
]  
```
Собственно, так мы и получим список всех тестов, которые постоянно падают. 

## Заключение

Это только один из примеров того, какую информацию вы можете раздобыть с отчетов с помощью утилиты jq. 
Я познакомился с ней примерно пол года назад, но реальной задачи тогда не было и я решил не пилить посто про нее. 
Это довольно мощный инструмент, который позволяет быстро решать много прикольных задач. 

А я устал писать этот пост, как на тренировку сходил. Нужно качать писAтельную (да-да, шутник) мышцу.
